<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Opium__Request (opium.Opium__Request)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">opium</a> &#x00BB; Opium__Request</nav><h1>Module <code>Opium__Request</code></h1><p>Module to create and work with HTTP requests.</p><p>It offers convenience functions to read headers, decode a request body or URI.</p><p>The requests are most likely provided to you by Opium when you are writing your application, but this module contains all the constructors and setters that you need to initialize new requests.</p><h4 id="working-with-stream-bodies"><a href="#working-with-stream-bodies" class="anchor"></a>Working with stream bodies</h4><p>All the functions in this module will clone the stream before reading from it, so you can process the body multiple times if needed. Just make sure that you didn't drain the body before calling a function that reads from it.</p><p>Functions from other modules may drain the body stream. You can use <span class="xref-unresolved" title="unresolved reference to &quot;Body.copy&quot;"><code>Body</code>.copy</span> to copy the body yourself.</p><nav class="toc"><ul><li><a href="#constructors">Constructors</a><ul><li><a href="#make"><code>make</code></a></li><li><a href="#get"><code>get</code></a></li><li><a href="#post"><code>post</code></a></li><li><a href="#put"><code>put</code></a></li><li><a href="#delete"><code>delete</code></a></li><li><a href="#of_plain_text"><code>of_plain_text</code></a></li><li><a href="#of_json"><code>of_json</code></a></li><li><a href="#of_urlencoded"><code>of_urlencoded</code></a></li></ul></li><li><a href="#decoders">Decoders</a><ul><li><a href="#to_plain_text"><code>to_plain_text</code></a></li><li><a href="#to_json"><code>to_json</code></a></li><li><a href="#to_json_exn"><code>to_json_exn</code></a></li><li><a href="#to_urlencoded"><code>to_urlencoded</code></a></li><li><a href="#to_multipart_form_data"><code>to_multipart_form_data</code></a></li><li><a href="#to_multipart_form_data_exn"><code>to_multipart_form_data_exn</code></a></li></ul></li><li><a href="#getters-and-setters">Getters and Setters</a><ul><li><a href="#general-headers">General Headers</a><ul><li><a href="#header"><code>header</code></a></li><li><a href="#headers"><code>headers</code></a></li><li><a href="#add_header"><code>add_header</code></a></li><li><a href="#add_header_or_replace"><code>add_header_or_replace</code></a></li><li><a href="#add_header_unless_exists"><code>add_header_unless_exists</code></a></li><li><a href="#add_headers"><code>add_headers</code></a></li><li><a href="#add_headers_or_replace"><code>add_headers_or_replace</code></a></li><li><a href="#add_headers_unless_exists"><code>add_headers_unless_exists</code></a></li><li><a href="#remove_header"><code>remove_header</code></a></li></ul></li><li><a href="#specific-headers">Specific Headers</a><ul><li><a href="#content_type"><code>content_type</code></a></li><li><a href="#set_content_type"><code>set_content_type</code></a></li></ul></li><li><a href="#cookies">Cookies</a><ul><li><a href="#cookie"><code>cookie</code></a></li><li><a href="#cookies"><code>cookies</code></a></li><li><a href="#add_cookie"><code>add_cookie</code></a></li><li><a href="#add_cookie_unless_exists"><code>add_cookie_unless_exists</code></a></li><li><a href="#remove_cookie"><code>remove_cookie</code></a></li></ul></li><li><a href="#body">Body</a><ul><li><a href="#urlencoded"><code>urlencoded</code></a></li><li><a href="#urlencoded_exn"><code>urlencoded_exn</code></a></li><li><a href="#urlencoded_list"><code>urlencoded_list</code></a></li></ul></li><li><a href="#uri">URI</a><ul><li><a href="#query"><code>query</code></a></li><li><a href="#query_exn"><code>query_exn</code></a></li><li><a href="#query_list"><code>query_list</code></a></li></ul></li></ul></li><li><a href="#utilities">Utilities</a><ul><li><a href="#sexp_of_t"><code>sexp_of_t</code></a></li><li><a href="#pp"><code>pp</code></a></li><li><a href="#pp_hum"><code>pp_hum</code></a></li></ul></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../../rock/Rock/Request/index.html#type-t">Rock.Request.t</a></code><code> = </code><code>{</code><table class="record"><tr id="type-t.version" class="anchored"><td class="def field"><a href="#type-t.version" class="anchor"></a><code>version : <a href="../Opium/Version/index.html#type-t">Opium.Version.t</a>;</code></td></tr><tr id="type-t.target" class="anchored"><td class="def field"><a href="#type-t.target" class="anchor"></a><code>target : string;</code></td></tr><tr id="type-t.headers" class="anchored"><td class="def field"><a href="#type-t.headers" class="anchor"></a><code>headers : <a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a>;</code></td></tr><tr id="type-t.meth" class="anchored"><td class="def field"><a href="#type-t.meth" class="anchor"></a><code>meth : <a href="../Opium/Method/index.html#type-t">Opium.Method.t</a>;</code></td></tr><tr id="type-t.body" class="anchored"><td class="def field"><a href="#type-t.body" class="anchor"></a><code>body : <a href="../Opium/Body/index.html#type-t">Opium.Body.t</a>;</code></td></tr><tr id="type-t.env" class="anchored"><td class="def field"><a href="#type-t.env" class="anchor"></a><code>env : <a href="../Opium/Context/index.html#type-t">Opium.Context.t</a>;</code></td></tr></table><code>}</code></dt></dl><section><header><h2 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h2></header><section><header><h4 id="make"><a href="#make" class="anchor"></a><code>make</code></h4></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span>?&#8288;version:<a href="../Opium/Version/index.html#type-t">Opium.Version.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;body:<a href="../Opium/Body/index.html#type-t">Opium.Body.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="../Opium/Context/index.html#type-t">Opium.Context.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;headers:<a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Opium/Method/index.html#type-t">Opium.Method.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>make ?version ?body ?env ?headers target method</code> creates a new request from the given values.</p><p>By default, the HTTP version will be set to 1.1 and the request will not contain any header or body.</p></dd></dl></section><section><header><h4 id="get"><a href="#get" class="anchor"></a><code>get</code></h4></header><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span>?&#8288;version:<a href="../Opium/Version/index.html#type-t">Opium.Version.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;body:<a href="../Opium/Body/index.html#type-t">Opium.Body.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="../Opium/Context/index.html#type-t">Opium.Context.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;headers:<a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>get ?version ?body ?env ?headers target</code> creates a new <code>GET</code> request from the given values.</p><p>By default, the HTTP version will be set to 1.1 and the request will not contain any header or body.</p></dd></dl></section><section><header><h4 id="post"><a href="#post" class="anchor"></a><code>post</code></h4></header><dl><dt class="spec value" id="val-post"><a href="#val-post" class="anchor"></a><code><span class="keyword">val</span> post : <span>?&#8288;version:<a href="../Opium/Version/index.html#type-t">Opium.Version.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;body:<a href="../Opium/Body/index.html#type-t">Opium.Body.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="../Opium/Context/index.html#type-t">Opium.Context.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;headers:<a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>post ?version ?body ?env ?headers target</code> creates a new <code>POST</code> request from the given values.</p><p>By default, the HTTP version will be set to 1.1 and the request will not contain any header or body.</p></dd></dl></section><section><header><h4 id="put"><a href="#put" class="anchor"></a><code>put</code></h4></header><dl><dt class="spec value" id="val-put"><a href="#val-put" class="anchor"></a><code><span class="keyword">val</span> put : <span>?&#8288;version:<a href="../Opium/Version/index.html#type-t">Opium.Version.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;body:<a href="../Opium/Body/index.html#type-t">Opium.Body.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="../Opium/Context/index.html#type-t">Opium.Context.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;headers:<a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>put ?version ?body ?env ?headers target</code> creates a new <code>PUT</code> request from the given values.</p><p>By default, the HTTP version will be set to 1.1 and the request will not contain any header or body.</p></dd></dl></section><section><header><h4 id="delete"><a href="#delete" class="anchor"></a><code>delete</code></h4></header><dl><dt class="spec value" id="val-delete"><a href="#val-delete" class="anchor"></a><code><span class="keyword">val</span> delete : <span>?&#8288;version:<a href="../Opium/Version/index.html#type-t">Opium.Version.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;body:<a href="../Opium/Body/index.html#type-t">Opium.Body.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="../Opium/Context/index.html#type-t">Opium.Context.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;headers:<a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>delete ?version ?body ?env ?headers target</code> creates a new <code>DELETE</code> request from the given values.</p><p>By default, the HTTP version will be set to 1.1 and the request will not contain any header or body.</p></dd></dl></section><section><header><h4 id="of_plain_text"><a href="#of_plain_text" class="anchor"></a><code>of_plain_text</code></h4></header><dl><dt class="spec value" id="val-of_plain_text"><a href="#val-of_plain_text" class="anchor"></a><code><span class="keyword">val</span> of_plain_text : <span>?&#8288;version:<a href="../Opium/Version/index.html#type-t">Opium.Version.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;headers:<a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="../Opium/Context/index.html#type-t">Opium.Context.t</a></span> <span>&#45;&gt;</span> <span>body:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Opium/Method/index.html#type-t">Opium.Method.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_plain_text ?version ?headers ?env ~body target method</code> creates a new request from the given values and a string body.</p><p>The content type of the request will be set to <code>text/plain</code> and the body will contain the string <code>body</code>.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><p>The request initialized with:</p><pre><code class="ml">Request.of_plain_text ~body:&quot;Hello World&quot; &quot;/target&quot; `POST </code></pre><p>Will be represented as:</p> <pre>
POST /target HTTP/HTTP/1.1
Content-Type: text/plain

Hello World </pre></dd></dl></section><section><header><h4 id="of_json"><a href="#of_json" class="anchor"></a><code>of_json</code></h4></header><dl><dt class="spec value" id="val-of_json"><a href="#val-of_json" class="anchor"></a><code><span class="keyword">val</span> of_json : <span>?&#8288;version:<a href="../Opium/Version/index.html#type-t">Opium.Version.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;headers:<a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="../Opium/Context/index.html#type-t">Opium.Context.t</a></span> <span>&#45;&gt;</span> <span>body:Yojson.Safe.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Opium/Method/index.html#type-t">Opium.Method.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_json ?version ?headers ?env ~body target method</code> creates a new request from the given values and a json body.</p><p>The content type of the request will be set to <code>application/json</code> and the body will contain the json payload <code>body</code>.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><p>The request initialized with:</p><pre><code class="ml">Request.of_json ~body:(`Assoc [ &quot;Hello&quot;, `String &quot;World&quot; ]) &quot;/target&quot; `POST </code></pre><p>Will be represented as:</p> <pre>
POST /target HTTP/HTTP/1.1
Content-Type: application/json

{"Hello":"World"} </pre> </dd></dl></section><section><header><h4 id="of_urlencoded"><a href="#of_urlencoded" class="anchor"></a><code>of_urlencoded</code></h4></header><dl><dt class="spec value" id="val-of_urlencoded"><a href="#val-of_urlencoded" class="anchor"></a><code><span class="keyword">val</span> of_urlencoded : <span>?&#8288;version:<a href="../Opium/Version/index.html#type-t">Opium.Version.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;headers:<a href="../Opium/Headers/index.html#type-t">Opium.Headers.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="../Opium/Context/index.html#type-t">Opium.Context.t</a></span> <span>&#45;&gt;</span> <span>body:<span><span>(string * <span>string list</span>)</span> list</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Opium/Method/index.html#type-t">Opium.Method.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_urlencoded ?version ?headers ?env ~body target method</code> creates a new request from the given values and a urlencoded body.</p><p>The content type of the request will be set to <code>application/x-www-form-urlencoded</code> and the body will contain the key value pairs <code>body</code> formatted in the urlencoded format.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><p>The request initialized with:</p><pre><code class="ml">Request.of_urlencoded ~body:[ &quot;key&quot;, [ &quot;value&quot; ] ] &quot;/target&quot; `POST </code></pre><p>Will be represented as:</p> <pre>
POST /target HTTP/HTTP/1.1
Content-Type: application/x-www-form-urlencoded

key=value </pre> </dd></dl></section></section><section><header><h2 id="decoders"><a href="#decoders" class="anchor"></a>Decoders</h2></header><section><header><h4 id="to_plain_text"><a href="#to_plain_text" class="anchor"></a><code>to_plain_text</code></h4></header><dl><dt class="spec value" id="val-to_plain_text"><a href="#val-to_plain_text" class="anchor"></a><code><span class="keyword">val</span> to_plain_text : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>string Lwt.t</span></code></dt><dd><p><code>to_plain_text t</code> parses the body of the request <code>t</code> as a string.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><pre><code class="ml">let request = Request.of_plain_text &quot;Hello world!&quot;
let body = Request.to_json request</code></pre><p><code>body</code> will be:</p><pre><code class="ml">&quot;Hello world!&quot; </code></pre></dd></dl></section><section><header><h4 id="to_json"><a href="#to_json" class="anchor"></a><code>to_json</code></h4></header><dl><dt class="spec value" id="val-to_json"><a href="#val-to_json" class="anchor"></a><code><span class="keyword">val</span> to_json : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>Yojson.Safe.t option</span> Lwt.t</span></code></dt><dd><p><code>to_json t</code> parses the body of the request <code>t</code> as a JSON structure.</p><p>If the body of the request cannot be parsed as a JSON structure, <code>None</code> is returned. Use <a href="index.html#to_json_exn"><span><code>to_json_exn</code></span></a> to raise an exception instead.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><pre><code class="ml">let request = Request.of_json (`Assoc [ &quot;Hello&quot;, `String &quot;World&quot; ])
let body = Request.to_json request</code></pre><p><code>body</code> will be:</p><pre><code class="ml">`Assoc [ &quot;Hello&quot;, `String &quot;World&quot; ] </code></pre></dd></dl></section><section><header><h4 id="to_json_exn"><a href="#to_json_exn" class="anchor"></a><code>to_json_exn</code></h4></header><dl><dt class="spec value" id="val-to_json_exn"><a href="#val-to_json_exn" class="anchor"></a><code><span class="keyword">val</span> to_json_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Yojson.Safe.t Lwt.t</span></code></dt><dd><p><code>to_json_exn t</code> parses the body of the request <code>t</code> as a JSON structure.</p><p>If the body of the request cannot be parsed as a JSON structure, an <code>Invalid_argument</code> exception is raised. Use <a href="index.html#to_json"><span><code>to_json</code></span></a> to return an option instead.</p></dd></dl></section><section><header><h4 id="to_urlencoded"><a href="#to_urlencoded" class="anchor"></a><code>to_urlencoded</code></h4></header><dl><dt class="spec value" id="val-to_urlencoded"><a href="#val-to_urlencoded" class="anchor"></a><code><span class="keyword">val</span> to_urlencoded : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><span>(string * <span>string list</span>)</span> list</span> Lwt.t</span></code></dt><dd><p><code>to_urlencoded t</code> parses the body of the request <code>t</code> from a urlencoded format to a list of key-values pairs.</p><p>This function exist to offer a simple way to get all of the key-values pairs, but most of the time, you'll probably only want the value of a key given. If you don't need the entire list of values, it is recommended to use <a href="index.html#urlencoded"><span><code>urlencoded</code></span></a> instead.</p><p>If the body of the request cannot be parsed as a urlencoded string, an empty list is returned.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><pre><code class="ml">let request =
  Request.of_urlencoded
    ~body:[ &quot;username&quot;, [ &quot;admin&quot; ]; &quot;password&quot;, [ &quot;password&quot; ] ]
    &quot;/&quot;
    `POST
;;

let values = Request.to_urlencoded request</code></pre><p><code>values</code> will be:</p><pre><code class="ml">[ &quot;username&quot;, [ &quot;admin&quot; ]; &quot;password&quot;, [ &quot;password&quot; ] ] </code></pre></dd></dl></section><section><header><h4 id="to_multipart_form_data"><a href="#to_multipart_form_data" class="anchor"></a><code>to_multipart_form_data</code></h4></header><dl><dt class="spec value" id="val-to_multipart_form_data"><a href="#val-to_multipart_form_data" class="anchor"></a><code><span class="keyword">val</span> to_multipart_form_data : <span>?&#8288;callback:<span>(<span>name:string</span> <span>&#45;&gt;</span> <span>filename:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><span><span>(string * string)</span> list</span> option</span> Lwt.t</span></code></dt><dd><p><code>to_multipart_form_data ?callback t</code> parses the body of the request <code>t</code> from a <code>multipart/form-data</code> format to a list of key-values pairs.</p><p>The request has to to contain a <code>Content-Type</code> header with a value <code>multipart/form-data</code> and the HTTP method has to be <code>POST</code>, otherwise the request will not be parsed an <code>None</code> will be returned. See <a href="index.html#to_multipart_form_data_exn"><span><code>to_multipart_form_data_exn</code></span></a> to raise an exception instead.</p><p>If the body of the request cannot be parsed as a <code>multipart/form-data</code> string, an empty list is returned.</p><p>When provided, the callback is a function of type <code>val _ : ~filename:string ~name:string string -&gt; Lwt.unit</code> that is called for each part of the body.</p></dd></dl></section><section><header><h4 id="to_multipart_form_data_exn"><a href="#to_multipart_form_data_exn" class="anchor"></a><code>to_multipart_form_data_exn</code></h4></header><dl><dt class="spec value" id="val-to_multipart_form_data_exn"><a href="#val-to_multipart_form_data_exn" class="anchor"></a><code><span class="keyword">val</span> to_multipart_form_data_exn : <span>?&#8288;callback:<span>(<span>name:string</span> <span>&#45;&gt;</span> <span>filename:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><span>(string * string)</span> list</span> Lwt.t</span></code></dt><dd><p><code>to_multipart_form_data_exn ?callback t</code> parses the body of the request <code>t</code> from a <code>multipart/form-data</code> format to a list of key-values pairs.</p><p>The request has to to contain a <code>Content-Type</code> header with a value <code>multipart/form-data</code> and the HTTP method has to be <code>POST</code>, otherwise the request will not be parsed and an <code>Invalid_argument</code> exception will be raised. See <a href="index.html#to_multipart_form_data"><span><code>to_multipart_form_data</code></span></a> to return an option instead.</p><p>If the body of the request cannot be parsed as a <code>multipart/form-data</code> string, an empty list is returned.</p><p>When provided, the callback is a function of type <code>val _ : ~filename:string ~name:string string -&gt; Lwt.unit</code> that is called for each part of the body.</p></dd></dl></section></section><section><header><h2 id="getters-and-setters"><a href="#getters-and-setters" class="anchor"></a>Getters and Setters</h2></header><section><header><h3 id="general-headers"><a href="#general-headers" class="anchor"></a>General Headers</h3></header><section><header><h4 id="header"><a href="#header" class="anchor"></a><code>header</code></h4></header><dl><dt class="spec value" id="val-header"><a href="#val-header" class="anchor"></a><code><span class="keyword">val</span> header : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p><code>header key t</code> returns the value of the header with key <code>key</code> in the request <code>t</code>.</p><p>If multiple headers have the key <code>key</code>, only the value of the first header will be returned.</p><p>If you want to return all the values if multiple headers are found, you can use <a href="index.html#type-t.headers"><code>headers</code></a>.</p></dd></dl></section><section><header><h4 id="headers"><a href="#headers" class="anchor"></a><code>headers</code></h4></header><dl><dt class="spec value" id="val-headers"><a href="#val-headers" class="anchor"></a><code><span class="keyword">val</span> headers : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p><code>headers</code> returns the values of all headers with the key <code>key</code> in the request <code>t</code>.</p><p>If you want to return the value of only the first header with the key <code>key</code>, you can use <a href="index.html#header"><span><code>header</code></span></a>.</p></dd></dl></section><section><header><h4 id="add_header"><a href="#add_header" class="anchor"></a><code>add_header</code></h4></header><dl><dt class="spec value" id="val-add_header"><a href="#val-add_header" class="anchor"></a><code><span class="keyword">val</span> add_header : <span>(string * string)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_header (key, value) t</code> adds a header with the key <code>key</code> and the value <code>value</code> to the request <code>t</code>.</p><p>If a header with the same key is already persent, a new header is appended to the list of headers regardless. If you want to add the header only if an header with the same key could not be found, you can use <a href="index.html#add_header_unless_exists"><span><code>add_header_unless_exists</code></span></a>.</p><p>See also <a href="index.html#add_headers"><span><code>add_headers</code></span></a> to add multiple headers.</p></dd></dl></section><section><header><h4 id="add_header_or_replace"><a href="#add_header_or_replace" class="anchor"></a><code>add_header_or_replace</code></h4></header><dl><dt class="spec value" id="val-add_header_or_replace"><a href="#val-add_header_or_replace" class="anchor"></a><code><span class="keyword">val</span> add_header_or_replace : <span>(string * string)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_header_or_replace (key, value) t</code> adds a header with the key <code>key</code> and the value <code>value</code> to the request <code>t</code>.</p><p>If a header with the same key already exist, its value is replaced by <code>value</code>. If you want to add the header only if it doesn't already exist, you can use <a href="index.html#add_header_unless_exists"><span><code>add_header_unless_exists</code></span></a>.</p><p>See also <a href="index.html#add_headers_or_replace"><span><code>add_headers_or_replace</code></span></a> to add multiple headers.</p></dd></dl></section><section><header><h4 id="add_header_unless_exists"><a href="#add_header_unless_exists" class="anchor"></a><code>add_header_unless_exists</code></h4></header><dl><dt class="spec value" id="val-add_header_unless_exists"><a href="#val-add_header_unless_exists" class="anchor"></a><code><span class="keyword">val</span> add_header_unless_exists : <span>(string * string)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_header_unless_exists (key, value) t</code> adds a header with the key <code>key</code> and the value <code>value</code> to the request <code>t</code> if an header with the same key does not already exist.</p><p>If a header with the same key already exist, the request remains unmodified. If you want to add the header regardless of whether the header is already present, you can use <a href="index.html#add_header"><span><code>add_header</code></span></a>.</p><p>See also <a href="index.html#add_headers_unless_exists"><span><code>add_headers_unless_exists</code></span></a> to add multiple headers.</p></dd></dl></section><section><header><h4 id="add_headers"><a href="#add_headers" class="anchor"></a><code>add_headers</code></h4></header><dl><dt class="spec value" id="val-add_headers"><a href="#val-add_headers" class="anchor"></a><code><span class="keyword">val</span> add_headers : <span><span>(string * string)</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_headers headers t</code> adds the headers <code>headers</code> to the request <code>t</code>.</p><p>The headers are added regardless of whether a header with the same key is already present. If you want to add the header only if an header with the same key could not be found, you can use <a href="index.html#add_headers_unless_exists"><span><code>add_headers_unless_exists</code></span></a>.</p><p>See also <a href="index.html#add_header"><span><code>add_header</code></span></a> to add a single header.</p></dd></dl></section><section><header><h4 id="add_headers_or_replace"><a href="#add_headers_or_replace" class="anchor"></a><code>add_headers_or_replace</code></h4></header><dl><dt class="spec value" id="val-add_headers_or_replace"><a href="#val-add_headers_or_replace" class="anchor"></a><code><span class="keyword">val</span> add_headers_or_replace : <span><span>(string * string)</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_headers_or_replace (key, value) t</code> adds a headers <code>headers</code> to the request <code>t</code>.</p><p>If a header with the same key already exist, its value is replaced by <code>value</code>. If you want to add the header only if it doesn't already exist, you can use <a href="index.html#add_headers_unless_exists"><span><code>add_headers_unless_exists</code></span></a>.</p><p>See also <a href="index.html#add_header_or_replace"><span><code>add_header_or_replace</code></span></a> to add a single header.</p></dd></dl></section><section><header><h4 id="add_headers_unless_exists"><a href="#add_headers_unless_exists" class="anchor"></a><code>add_headers_unless_exists</code></h4></header><dl><dt class="spec value" id="val-add_headers_unless_exists"><a href="#val-add_headers_unless_exists" class="anchor"></a><code><span class="keyword">val</span> add_headers_unless_exists : <span><span>(string * string)</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_headers_unless_exists headers t</code> adds the headers <code>headers</code> to the request <code>t</code> if an header with the same key does not already exist.</p><p>If a header with the same key already exist, the header is will not be added to the request. If you want to add the header regardless of whether the header is already present, you can use <a href="index.html#add_headers"><span><code>add_headers</code></span></a>.</p><p>See also <a href="index.html#add_header_unless_exists"><span><code>add_header_unless_exists</code></span></a> to add a single header.</p></dd></dl></section><section><header><h4 id="remove_header"><a href="#remove_header" class="anchor"></a><code>remove_header</code></h4></header><dl><dt class="spec value" id="val-remove_header"><a href="#val-remove_header" class="anchor"></a><code><span class="keyword">val</span> remove_header : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_header (key, value) t</code> removes all the headers with the key <code>key</code> from the request <code>t</code>.</p><p>If no header with the key <code>key</code> exist, the request remains unmodified.</p></dd></dl></section></section><section><header><h3 id="specific-headers"><a href="#specific-headers" class="anchor"></a>Specific Headers</h3></header><section><header><h4 id="content_type"><a href="#content_type" class="anchor"></a><code>content_type</code></h4></header><dl><dt class="spec value" id="val-content_type"><a href="#val-content_type" class="anchor"></a><code><span class="keyword">val</span> content_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p><code>content_type t</code> returns the value of the header <code>Content-Type</code> of the request <code>t</code>.</p></dd></dl></section><section><header><h4 id="set_content_type"><a href="#set_content_type" class="anchor"></a><code>set_content_type</code></h4></header><dl><dt class="spec value" id="val-set_content_type"><a href="#val-set_content_type" class="anchor"></a><code><span class="keyword">val</span> set_content_type : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set_content_type content_type t</code> returns a copy of <code>t</code> with the value of the header <code>Content-Type</code> set to <code>content_type</code>.</p></dd></dl></section></section><section><header><h3 id="cookies"><a href="#cookies" class="anchor"></a>Cookies</h3></header><section><header><h4 id="cookie"><a href="#cookie" class="anchor"></a><code>cookie</code></h4></header><dl><dt class="spec value" id="val-cookie"><a href="#val-cookie" class="anchor"></a><code><span class="keyword">val</span> cookie : <span>?&#8288;signed_with:<a href="../Opium/Cookie/Signer/index.html#type-t">Opium.Cookie.Signer.t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p><code>cookie ?signed_with key t</code> returns the value of the cookie with key <code>key</code> in the <code>Cookie</code> header of the request <code>t</code>.</p><p>If <code>signed_with</code> is provided, the cookies will be unsigned with the given Signer and only a cookie with a valid signature will be returned.</p><p>If the request does not contain a valid <code>Cookie</code> or if no cookie with the key <code>key</code> exist, <code>None</code> will be returned.</p></dd></dl></section><section><header><h4 id="cookies"><a href="#cookies" class="anchor"></a><code>cookies</code></h4></header><dl><dt class="spec value" id="val-cookies"><a href="#val-cookies" class="anchor"></a><code><span class="keyword">val</span> cookies : <span>?&#8288;signed_with:<a href="../Opium/Cookie/Signer/index.html#type-t">Opium.Cookie.Signer.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Opium/Cookie/index.html#type-value">Opium.Cookie.value</a> list</span></code></dt><dd><p><code>cookies ?signed_with t</code> returns all the value of the cookies in the <code>Cookie</code> header of the request <code>t</code>.</p><p>If <code>signed_with</code> is provided, the cookies will be unsigned with the given Signer and only the cookies with a valid signature will be returned.</p><p>If the request does not contain a valid <code>Cookie</code>, <code>None</code> will be returned.</p></dd></dl></section><section><header><h4 id="add_cookie"><a href="#add_cookie" class="anchor"></a><code>add_cookie</code></h4></header><dl><dt class="spec value" id="val-add_cookie"><a href="#val-add_cookie" class="anchor"></a><code><span class="keyword">val</span> add_cookie : <span>?&#8288;sign_with:<a href="../Opium/Cookie/Signer/index.html#type-t">Opium.Cookie.Signer.t</a></span> <span>&#45;&gt;</span> <a href="../Opium/Cookie/index.html#type-value">Opium.Cookie.value</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_cookie ?sign_with ?expires ?scope ?same_site ?secure ?http_only value t</code> adds a cookie with value <code>value</code> to the request <code>t</code>.</p><p>If a cookie with the same key already exists, its value will be replaced with the new value of <code>value</code>.</p><p>If <code>sign_with</code> is provided, the cookie will be signed with the given Signer.</p></dd></dl></section><section><header><h4 id="add_cookie_unless_exists"><a href="#add_cookie_unless_exists" class="anchor"></a><code>add_cookie_unless_exists</code></h4></header><dl><dt class="spec value" id="val-add_cookie_unless_exists"><a href="#val-add_cookie_unless_exists" class="anchor"></a><code><span class="keyword">val</span> add_cookie_unless_exists : <span>?&#8288;sign_with:<a href="../Opium/Cookie/Signer/index.html#type-t">Opium.Cookie.Signer.t</a></span> <span>&#45;&gt;</span> <a href="../Opium/Cookie/index.html#type-value">Opium.Cookie.value</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_cookie_unless_exists ?sign_with ?expires ?scope ?same_site ?secure ?http_only
    value t</code> adds a cookie with value <code>value</code> to the request <code>t</code>.</p><p>If a cookie with the same key already exists, it will remain untouched.</p><p>If <code>sign_with</code> is provided, the cookie will be signed with the given Signer.</p></dd></dl></section><section><header><h4 id="remove_cookie"><a href="#remove_cookie" class="anchor"></a><code>remove_cookie</code></h4></header><dl><dt class="spec value" id="val-remove_cookie"><a href="#val-remove_cookie" class="anchor"></a><code><span class="keyword">val</span> remove_cookie : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_cookie key t</code> removes the cookie of key <code>key</code> from the <code>Cookie</code> header of the request <code>t</code>.</p></dd></dl></section></section><section><header><h3 id="body"><a href="#body" class="anchor"></a>Body</h3></header><section><header><h4 id="urlencoded"><a href="#urlencoded" class="anchor"></a><code>urlencoded</code></h4></header><dl><dt class="spec value" id="val-urlencoded"><a href="#val-urlencoded" class="anchor"></a><code><span class="keyword">val</span> urlencoded : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>string option</span> Lwt.t</span></code></dt><dd><p><code>urlencoded key t</code> returns the first value associated to <code>key</code> in the urlencoded body of the request <code>t</code>.</p><p>The function only returns the first value for the given key, because in the great majority of cases, there is only one parameter per key. If you want to return all the values associated to the key, you can use <a href="index.html#to_urlencoded"><span><code>to_urlencoded</code></span></a>.</p><p>If the key could not be found or if the request could not be parsed as urlencoded, <code>None</code> is returned. Use <a href="index.html#urlencoded_exn"><span><code>urlencoded_exn</code></span></a> to raise an exception instead.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><pre><code class="ml">let request =
  Request.of_urlencoded
    ~body:[ &quot;username&quot;, [ &quot;admin&quot; ]; &quot;password&quot;, [ &quot;password&quot; ] ]
    &quot;/&quot;
    `POST
;;

let username = Request.urlencoded &quot;username&quot; request</code></pre><p><code>username</code> will be:</p><pre><code class="ml">Some &quot;admin&quot; </code></pre></dd></dl></section><section><header><h4 id="urlencoded_exn"><a href="#urlencoded_exn" class="anchor"></a><code>urlencoded_exn</code></h4></header><dl><dt class="spec value" id="val-urlencoded_exn"><a href="#val-urlencoded_exn" class="anchor"></a><code><span class="keyword">val</span> urlencoded_exn : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>string Lwt.t</span></code></dt><dd><p><code>urlencoded_exn key t</code> returns the first value associated to <code>key</code> in the urlencoded body of the request <code>t</code>.</p><p>The function only returns the first value for the given key, because in the great majority of cases, there is only one parameter per key. If you want to return all the values associated to the key, you can use <a href="index.html#to_urlencoded"><span><code>to_urlencoded</code></span></a>.</p><p>If the key could not be found or if the request could not be parsed as urlencoded, an <code>Invalid_argument</code> exception is raised. Use <a href="index.html#urlencoded"><span><code>urlencoded</code></span></a> to return an option instead.</p></dd></dl></section><section><header><h4 id="urlencoded_list"><a href="#urlencoded_list" class="anchor"></a><code>urlencoded_list</code></h4></header><dl><dt class="spec value" id="val-urlencoded_list"><a href="#val-urlencoded_list" class="anchor"></a><code><span class="keyword">val</span> urlencoded_list : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>string list</span> Lwt.t</span></code></dt><dd><p><code>urlencoded_list key t</code> returns all the values associated to <code>key</code> in the urlencoded body of the request <code>t</code>.</p><p>If the key could not be found or if the request could not be parsed as urlencoded, an empty list <code>[]</code> is returned instead.</p></dd></dl></section></section><section><header><h3 id="uri"><a href="#uri" class="anchor"></a>URI</h3></header><section><header><h4 id="query"><a href="#query" class="anchor"></a><code>query</code></h4></header><dl><dt class="spec value" id="val-query"><a href="#val-query" class="anchor"></a><code><span class="keyword">val</span> query : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p><code>query key t</code> returns the first value associated to <code>key</code> in the URI query parameters of the request <code>t</code>.</p><p>The function only returns the first value for the given key, because in the great majority of cases, there is only one parameter per key. If you want to return all the values associated to the key, you can use <a href="index.html#query_list"><span><code>query_list</code></span></a>.</p><p>If the key could not be found or if the request URI does not contain any query parameter, <code>None</code> is returned. Use <a href="index.html#query_exn"><span><code>query_exn</code></span></a> to raise an exception instead.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><pre><code class="ml">let request = Request.make &quot;/target?key=value&quot; `GET
let query = Request.query &quot;key&quot; request</code></pre><p><code>query</code> will be:</p><pre><code class="ml">Some &quot;value&quot; </code></pre></dd></dl></section><section><header><h4 id="query_exn"><a href="#query_exn" class="anchor"></a><code>query_exn</code></h4></header><dl><dt class="spec value" id="val-query_exn"><a href="#val-query_exn" class="anchor"></a><code><span class="keyword">val</span> query_exn : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>query_exn key t</code> returns the first value associated to <code>key</code> in the URI query parameters of the request <code>t</code>.</p><p>The function only returns the first value for the given key, because in the great majority of cases, there is only one parameter per key. If you want to return all the values associated to the key, you can use <a href="index.html#query_list"><span><code>query_list</code></span></a>.</p><p>If the key could not be found or if the request URI does not contain any query parameter, an <code>Invalid_argument</code> exception is raised. Use <a href="index.html#query"><span><code>query</code></span></a> to return an option instead.</p></dd></dl></section><section><header><h4 id="query_list"><a href="#query_list" class="anchor"></a><code>query_list</code></h4></header><dl><dt class="spec value" id="val-query_list"><a href="#val-query_list" class="anchor"></a><code><span class="keyword">val</span> query_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(string * <span>string list</span>)</span> list</span></code></dt><dd><p><code>query_list key t</code> returns all the values associated to <code>key</code> in the URI query parameters of the request <code>t</code>.</p><p>This function exist to offer a simple way to get all of the values associated to a key, but most of the time, there is only one value per key. If you're not specifically trying to decode a request with multiple values per key, it is recommended to use <a href="index.html#query"><span><code>query</code></span></a> instead.</p><p>If the key could not be found or if the request could not be parsed as query, an empty list is returned.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><pre><code class="ml">let request = Request.make &quot;/target?key=value&amp;key2=value2&quot; `GET
let values = Request.query_list request</code></pre><p><code>values</code> will be:</p><pre><code class="ml">[ &quot;key&quot;, [ &quot;value&quot; ]; &quot;key2&quot;, [ &quot;value2&quot; ] ] </code></pre></dd></dl></section></section></section><section><header><h2 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h2></header><section><header><h4 id="sexp_of_t"><a href="#sexp_of_t" class="anchor"></a><code>sexp_of_t</code></h4></header><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Sexplib0.Sexp.t</code></dt><dd><p><code>sexp_of_t t</code> converts the request <code>t</code> to an s-expression</p></dd></dl></section><section><header><h4 id="pp"><a href="#pp" class="anchor"></a><code>pp</code></h4></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp</code> formats the request <code>t</code> as an s-expression</p></dd></dl></section><section><header><h4 id="pp_hum"><a href="#pp_hum" class="anchor"></a><code>pp_hum</code></h4></header><dl><dt class="spec value" id="val-pp_hum"><a href="#val-pp_hum" class="anchor"></a><code><span class="keyword">val</span> pp_hum : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_hum</code> formats the request <code>t</code> as a standard HTTP request</p></dd></dl></section></section></div></body></html>